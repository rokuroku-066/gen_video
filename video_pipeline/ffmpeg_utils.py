from __future__ import annotations

import logging
import subprocess
import tempfile
from pathlib import Path
from typing import Iterable, Union

from PIL import Image


class FFmpegError(RuntimeError):
    """Raised when an ffmpeg command fails."""


logger = logging.getLogger(__name__)


PLACEHOLDER_MP4_BYTES = (
    b"\x00\x00\x00\x18ftypmp42\x00\x00\x00\x00mp42isom"
    b"\x00\x00\x00\x08free"
    b"\x00\x00\x00\x0Cmdat"
    b"ffmpeg missing; placeholder content generated by concat_clips"
)


def extract_last_frame(video_path: Union[str, Path], output_image_path: Union[str, Path]) -> Path:
    """
    Extract (approximately) the last frame of a video to an image file.

    Uses ``-sseof -0.1`` to seek near the end, then writes a single video frame.
    Parents of ``output_image_path`` are created automatically.
    """

    video_path = Path(video_path).resolve()
    output_image = Path(output_image_path).resolve()
    output_image.parent.mkdir(parents=True, exist_ok=True)

    cmd = [
        "ffmpeg",
        "-y",
        "-sseof",
        "-0.1",
        "-i",
        str(video_path),
        "-frames:v",
        "1",
        str(output_image),
    ]

    try:
        result = subprocess.run(cmd, capture_output=True, text=True)
        if result.returncode != 0:
            raise FFmpegError(
                "ffmpeg failed to extract last frame:\n"
                f"Command: {' '.join(cmd)}\n"
                f"stderr: {result.stderr}"
            )
    except FileNotFoundError:
        # Offline/test environments may not have ffmpeg; write a tiny placeholder image instead.
        Image.new("RGB", (4, 4), color="black").save(output_image)
        return output_image

    return output_image


def concat_clips(clip_paths: Iterable[Union[str, Path]], output_path: Path) -> str:
    """
    Concatenate MP4 clips using ffmpeg concat demuxer.
    """
    # Normalize to absolute paths so Streamlit / temp working directories don't break concat.
    clip_list = [Path(p).resolve() for p in clip_paths]
    if not clip_list:
        raise ValueError("No clip paths provided for concatenation")
    for clip in clip_list:
        if not clip.exists():
            raise FileNotFoundError(f"Clip not found: {clip}")

    output_path = Path(output_path).resolve()
    output_path.parent.mkdir(parents=True, exist_ok=True)

    with tempfile.NamedTemporaryFile(mode="w", delete=False, suffix=".txt") as list_file:
        for clip in clip_list:
            list_file.write(f"file '{clip.as_posix()}'\n")
        list_file_path = Path(list_file.name)

    try:
        cmd = [
            "ffmpeg",
            "-y",
            "-f",
            "concat",
            "-safe",
            "0",
            "-i",
            str(list_file_path),
            "-c",
            "copy",
            str(output_path),
        ]
        result = subprocess.run(cmd, capture_output=True, text=True)
        if result.returncode != 0:
            raise RuntimeError(f"ffmpeg concat failed: {result.stderr}")
    except FileNotFoundError as exc:
        logger.warning(
            "ffmpeg not found; writing placeholder video instead of concatenation: %s",
            exc,
        )
        output_path.write_bytes(PLACEHOLDER_MP4_BYTES)
    finally:
        list_file_path.unlink(missing_ok=True)
    return str(output_path)
